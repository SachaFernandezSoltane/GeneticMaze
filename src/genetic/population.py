from random import randint, choice
from src.genetic.people import People


class Population:
    """
    Represents a population of individuals for the genetic maze solver.

    Attributes:
        size (int): Number of individuals in the population.
        individuals (list[People]): List of People instances.
        best_individuals (list[People]): Currently selected best individuals.
        start_pos (tuple[int, int]): Starting coordinates of all individuals.
        cols (int): Number of columns in the maze.
        rows (int): Number of rows in the maze.

    Constants:
        MUTATION_RATE (float): Probability of a move mutating during reproduction.
        SELECTING_BEST_INDIVIDUALS (int): Number of best individuals to select for crossover.
    """

    MUTATION_RATE = 0.05
    SELECTING_BEST_INDIVIDUALS = 2

    def __init__(self, size, start_pos, cols, rows, best_path):
        """
        Initialize a Population instance.

        Args:
            size (int): Number of individuals in the population.
            start_pos (tuple[int, int]): Starting coordinates (x, y).
            cols (int): Number of columns in the maze.
            rows (int): Number of rows in the maze.
            best_path (list[tuple[int, int]]): Optimal path for fitness guidance.
        """
        self.size = size
        self.individuals = [People(start_pos, i, cols, rows, best_path) for i in range(size)]
        self.best_individuals = []
        self.start_pos = start_pos
        self.cols = cols
        self.rows = rows

    def evaluate(self):
        """Evaluate the fitness of all individuals in the population."""
        for ind in self.individuals:
            ind.fitness()

    def select_best(self):
        """
        Select the best individuals from the population.

        The selection favors individuals on the optimal path. If fewer than
        SELECTING_BEST_INDIVIDUALS are on the path, the closest off-path
        individuals are selected to fill the remaining slots.
        """
        self.evaluate()
        n = Population.SELECTING_BEST_INDIVIDUALS
        on_path, off_path = [], []

        for ind in self.individuals:
            if ind.position in ind.best_path:
                progress = ind.best_path.index(ind.position)
                on_path.append((progress, ind))
            else:
                x1, y1 = ind.position
                x2, y2 = ind.goal_pos
                manhattan = abs(x1 - x2) + abs(y1 - y2)
                off_path.append((manhattan, ind))

        selected = []
        if on_path:
            on_path_sorted = sorted(on_path, key=lambda x: -x[0])
            selected.extend([ind for _, ind in on_path_sorted[:n]])
        if len(selected) < n and off_path:
            off_path_sorted = sorted(off_path, key=lambda x: x[0])
            for _, ind in off_path_sorted:
                if len(selected) < n:
                    selected.append(ind)

        self.best_individuals = selected

    def mutate(self, moves):
        """
        Mutate a sequence of moves with a small probability.

        Args:
            moves (list[str]): List of moves ('up', 'down', 'left', 'right').

        Returns:
            list[str]: Mutated list of moves.
        """
        directions = ['up', 'down', 'left', 'right']
        mutated_moves = []
        for move in moves:
            if randint(1, 100) <= Population.MUTATION_RATE * 100:
                mutated_moves.append(choice(directions))
            else:
                mutated_moves.append(move)
        return mutated_moves

    def crossover_sections(self, A, B, sections=4):
        """
        Generate children by crossing over sections of two parents' moves.

        Args:
            A (list[str]): Moves of parent A.
            B (list[str]): Moves of parent B.
            sections (int, optional): Number of sections to split moves. Defaults to 4.

        Returns:
            list[list[str]]: List of children moves generated by different patterns.
        """
        size = len(A)
        step = size // sections
        cuts = [i * step for i in range(sections)] + [size]

        patterns = [
            [A, B, A, B],
            [B, A, B, A],
            [A, A, B, B],
            [B, B, A, A],
        ]

        children = []
        for pattern in patterns:
            child = []
            for i in range(sections):
                start, end = cuts[i], cuts[i + 1]
                child.extend(pattern[i][start:end])
            children.append(child)
        return children

    def generate_next_generation(self):
        """
        Generate the next generation of the population.

        The two best individuals are selected, crossed over to produce
        children, and mutated. Some new random individuals are also added
        to maintain diversity.
        """
        self.select_best()

        if len(self.best_individuals) < 2:
            return

        parent1, parent2 = self.best_individuals
        new_generation = []

        cross_children = self.crossover_sections(parent1.moves, parent2.moves)
        for idx, moves in enumerate(cross_children):
            moves = self.mutate(moves)
            new_generation.append(
                People(self.start_pos, idx,
                       self.cols, self.rows, self.individuals[0].best_path,
                       defined_moves=moves)
            )

        for i in range(8, 10):
            new_generation.append(
                People(self.start_pos, i,
                       self.cols, self.rows, self.individuals[0].best_path)
            )

        self.individuals = new_generation
